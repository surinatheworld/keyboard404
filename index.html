<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard404</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="game-container"></div>
    <div id="death-counter"><span id="skull">üíÄ</span><span id="death-count">0</span></div>
    <div id="height-indicator"><span>üìç </span><span id="current-height">0</span>m</div>
    <div id="troll-message" class="hidden"></div>
    <div id="teleport-hint">üöÄ 1-9 = Teleport | 0 = Finish (710m)</div>
    <div id="cat-popup" class="hidden">
        <img src="cat.png" alt="Laughing Cat">
        <p>Check your stupid skills and keyboard? üòπ</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script>
        const GameSettings = { asianMode: true, worldHeight: 8000, worldWidth: 800, wonkyMinHeight: 100 };

        class WonkyControls {
            constructor(scene) {
                this.scene = scene; this.isActive = false; this.currentGlitch = null;
                this.glitchTimer = null; this.cycleTimer = null; this.lastDirection = null;
                this.playerSprite = null;
                this.glitchTypes = [
                    { name: 'SWAP_CONTROLS', duration: 5000 },
                    { name: 'STICKY_KEYS', duration: 5000 },
                    { name: 'RANDOM_IGNORE', duration: 5000 },
                    { name: 'LOW_JUMP', duration: 5000 },
                    { name: 'SLIPPERY', duration: 5000 },
                    { name: 'REVERSE_JUMP', duration: 4000 }
                ];
            }
            setPlayer(sprite) { this.playerSprite = sprite; }
            getCurrentHeight() { return this.playerSprite ? Math.floor((GameSettings.worldHeight - this.playerSprite.y) / 10) : 0; }
            shouldActivate() { return this.getCurrentHeight() >= GameSettings.wonkyMinHeight; }
            start() { this.schedulNextGlitch(); }
            stop() { if (this.cycleTimer) this.cycleTimer.remove(); if (this.glitchTimer) this.glitchTimer.remove(); this.deactivateGlitch(); }
            schedulNextGlitch() { this.cycleTimer = this.scene.time.delayedCall(Phaser.Math.Between(6000, 12000), () => this.activateGlitch()); }
            activateGlitch() {
                if (!this.shouldActivate()) { this.schedulNextGlitch(); return; }
                const glitch = Phaser.Utils.Array.GetRandom(this.glitchTypes);
                this.currentGlitch = glitch; this.isActive = true;
                this.glitchTimer = this.scene.time.delayedCall(glitch.duration, () => { this.deactivateGlitch(); this.schedulNextGlitch(); });
            }
            deactivateGlitch() { this.isActive = false; this.currentGlitch = null; this.lastDirection = null; }
            processMovement(left, right) {
                if (!this.isActive) return { left, right, slippery: false };
                switch (this.currentGlitch.name) {
                    case 'SWAP_CONTROLS': return { left: right, right: left, slippery: false };
                    case 'STICKY_KEYS':
                        if (left) this.lastDirection = 'left'; if (right) this.lastDirection = 'right';
                        if (!left && !right && this.lastDirection) return { left: this.lastDirection === 'left', right: this.lastDirection === 'right', slippery: false };
                        return { left, right, slippery: false };
                    case 'RANDOM_IGNORE': return { left: left && Math.random() > 0.35, right: right && Math.random() > 0.35, slippery: false };
                    case 'SLIPPERY': return { left, right, slippery: true };
                    default: return { left, right, slippery: false };
                }
            }
            getJumpMultiplier() {
                if (!this.isActive) return 1.0;
                if (this.currentGlitch.name === 'LOW_JUMP') return 0.6;
                if (this.currentGlitch.name === 'REVERSE_JUMP') return -0.3;
                return 1.0;
            }
        }

        class Player {
            constructor(scene, x, y) {
                this.scene = scene; this.generateSprites();
                this.sprite = scene.physics.add.sprite(x, y, 'dog_idle');
                this.sprite.setCollideWorldBounds(true).setBounce(0.05).setSize(12, 14).setOffset(2, 2).setDrag(200, 0);
                this.speed = 200; this.jumpForce = -400; this.isAlive = true; this.canControl = true; this.highestY = y;
                this.bombStunned = false; this.bombDirection = 0;
                this.createAnimations();
            }
            generateSprites() {
                const c = { body: '#F5DEB3', dark: '#DEB887', nose: '#2F1810', eyes: '#1a1a1a', tongue: '#FF6B6B', collar: '#4169E1' };
                ['idle', 'run1', 'run2', 'jump', 'fall'].forEach(p => this.genSprite('dog_' + p, c, p));
            }
            genSprite(key, c, pose) {
                const g = this.scene.make.graphics({ add: false });
                g.fillStyle(Phaser.Display.Color.HexStringToColor(c.body).color);
                g.fillRect(3, 6, 10, 8); g.fillRect(4, 2, 8, 6);
                g.fillStyle(Phaser.Display.Color.HexStringToColor(c.dark).color);
                g.fillRect(3, 1, 3, 3); g.fillRect(10, 1, 3, 3); g.fillRect(4, 14, 2, 2); g.fillRect(10, 14, 2, 2); g.fillRect(12, 8, 2, 3);
                g.fillStyle(Phaser.Display.Color.HexStringToColor(c.eyes).color);
                g.fillRect(5, 4, 2, 2); g.fillRect(9, 4, 2, 2);
                g.fillStyle(0xffffff); g.fillRect(5, 4, 1, 1); g.fillRect(9, 4, 1, 1);
                g.fillStyle(Phaser.Display.Color.HexStringToColor(c.nose).color); g.fillRect(7, 6, 2, 1);
                g.fillStyle(Phaser.Display.Color.HexStringToColor(c.collar).color); g.fillRect(4, 8, 8, 2);
                if (pose === 'jump' || pose === 'fall') { g.fillStyle(Phaser.Display.Color.HexStringToColor(c.tongue).color); g.fillRect(7, 7, 2, 2); }
                g.generateTexture(key, 16, 16); g.destroy();
            }
            createAnimations() {
                this.scene.anims.create({ key: 'idle', frames: [{ key: 'dog_idle' }], frameRate: 1, repeat: -1 });
                this.scene.anims.create({ key: 'run', frames: [{ key: 'dog_run1' }, { key: 'dog_run2' }], frameRate: 10, repeat: -1 });
                this.scene.anims.create({ key: 'jump', frames: [{ key: 'dog_jump' }], frameRate: 1, repeat: -1 });
                this.scene.anims.create({ key: 'fall', frames: [{ key: 'dog_fall' }], frameRate: 1, repeat: -1 });
            }
            hitByBomb(direction) {
                this.bombStunned = true;
                this.bombDirection = direction;
                this.sprite.setTint(0xff6666);
                this.scene.time.delayedCall(500, () => { this.bombStunned = false; this.sprite.clearTint(); });
            }
            catStun() {
                this.bombStunned = true;
                this.bombDirection = Math.random() > 0.5 ? 1 : -1;
                this.sprite.setTint(0xff66ff);
                this.scene.time.delayedCall(500, () => { this.bombStunned = false; this.sprite.clearTint(); });
            }
            update(keys, wonky) {
                if (!this.isAlive || !this.canControl) return;
                const onFloor = this.sprite.body.onFloor();
                if (this.bombStunned) {
                    this.sprite.setVelocityX(this.bombDirection * this.speed * 1.5);
                    this.sprite.setFlipX(this.bombDirection < 0);
                    if (keys.jump && onFloor) this.sprite.setVelocityY(this.jumpForce);
                    if (!onFloor) this.sprite.anims.play(this.sprite.body.velocity.y > 0 ? 'fall' : 'jump', true);
                    else this.sprite.anims.play('run', true);
                    return;
                }
                const m = wonky.processMovement(keys.left, keys.right);
                if (m.left) { m.slippery ? this.sprite.setAccelerationX(-400) : this.sprite.setVelocityX(-this.speed); this.sprite.setFlipX(true); }
                else if (m.right) { m.slippery ? this.sprite.setAccelerationX(400) : this.sprite.setVelocityX(this.speed); this.sprite.setFlipX(false); }
                else { m.slippery ? this.sprite.setAccelerationX(0) : this.sprite.setVelocityX(0); }
                if (m.slippery) this.sprite.body.velocity.x = Phaser.Math.Clamp(this.sprite.body.velocity.x, -280, 280);
                if (keys.jump && onFloor) { this.sprite.setVelocityY(this.jumpForce * wonky.getJumpMultiplier()); this.highestY = this.sprite.y; }
                if (!keys.jumpHeld && this.sprite.body.velocity.y < -100) this.sprite.setVelocityY(this.sprite.body.velocity.y * 0.6);
                if (!onFloor) {
                    this.sprite.anims.play(this.sprite.body.velocity.y > 0 ? 'fall' : 'jump', true);
                    if (this.sprite.y < this.highestY) this.highestY = this.sprite.y;
                } else {
                    this.sprite.anims.play(Math.abs(this.sprite.body.velocity.x) > 10 ? 'run' : 'idle', true);
                    const fallDistance = (this.sprite.y - this.highestY) / 10;
                    if (fallDistance >= 36) { showCatPopup(); }
                    this.highestY = this.sprite.y;
                }
                document.getElementById('current-height').textContent = Math.max(0, Math.floor((GameSettings.worldHeight - this.sprite.y) / 10));
            }
            knockDown() { this.sprite.setVelocityY(250); this.scene.cameras.main.shake(80, 0.004); }
            getSprite() { return this.sprite; }
        }

        class MenuScene extends Phaser.Scene {
            constructor() { super({ key: 'MenuScene' }); }
            create() {
                const bg = this.add.graphics();
                bg.fillGradientStyle(0x1a1a2e, 0x16213e, 0x0f3460, 0x1a1a2e, 1);
                bg.fillRect(0, 0, 800, 600);
                for (let i = 0; i < 60; i++) {
                    const s = this.add.circle(Phaser.Math.Between(0, 800), Phaser.Math.Between(0, 600), Phaser.Math.Between(1, 2), 0xffffff, Phaser.Math.FloatBetween(0.3, 1));
                    this.tweens.add({ targets: s, alpha: 0.3, duration: Phaser.Math.Between(1000, 3000), yoyo: true, repeat: -1 });
                }
                this.add.text(400, 70, 'üêï ICY UNIVERSE üêï', { fontSize: '48px', fontFamily: 'Arial Black', color: '#fff', stroke: '#e94560', strokeThickness: 8 }).setOrigin(0.5);
                this.add.text(400, 130, '~ 710m EXTENDED EDITION ~', { fontSize: '20px', color: '#00ff00', fontStyle: 'italic' }).setOrigin(0.5);
                this.add.text(400, 175, '‚å®Ô∏è B√†n ph√≠m ng√°o t·ª´ 100m! ‚å®Ô∏è', { fontSize: '16px', color: '#ff6b6b' }).setOrigin(0.5);
                const btn = this.add.container(400, 280);
                const bg2 = this.add.graphics(); bg2.fillStyle(0xe94560, 1); bg2.fillRoundedRect(-100, -30, 200, 60, 16);
                btn.add([bg2, this.add.text(0, 0, '‚ñ∂  PLAY!', { fontSize: '28px', fontFamily: 'Arial Black', color: '#fff' }).setOrigin(0.5)]);
                const hit = this.add.rectangle(400, 280, 200, 60).setInteractive({ useHandCursor: true });
                hit.on('pointerover', () => this.tweens.add({ targets: btn, scaleX: 1.1, scaleY: 1.1, duration: 100 }));
                hit.on('pointerout', () => this.tweens.add({ targets: btn, scaleX: 1, scaleY: 1, duration: 100 }));
                hit.on('pointerdown', () => { this.cameras.main.fadeOut(500); this.time.delayedCall(500, () => this.scene.start('GameScene')); });
                this.tweens.add({ targets: btn, scaleX: 1.05, scaleY: 1.05, duration: 800, yoyo: true, repeat: -1 });
                this.add.text(400, 380, 'üéÆ WASD / Arrows + SPACE', { fontSize: '16px', color: '#aaa' }).setOrigin(0.5);
                this.add.text(400, 420, 'üöÄ 1-9 = Teleport to Checkpoints', { fontSize: '14px', color: '#00ff00' }).setOrigin(0.5);
                this.add.text(400, 460, 'üí£ Watch out for bomber planes!', { fontSize: '14px', color: '#ff6b6b' }).setOrigin(0.5);
            }
        }

        class GameScene extends Phaser.Scene {
            constructor() { super({ key: 'GameScene' }); }
            create() {
                GameState.reset();
                const W = GameSettings.worldWidth, H = GameSettings.worldHeight;
                this.physics.world.setBounds(0, 0, W, H);
                this.createBackground();
                this.platforms = this.physics.add.staticGroup();
                this.walls = this.physics.add.staticGroup();
                this.iceBlocks = this.physics.add.staticGroup();
                this.slopeLeft = this.physics.add.staticGroup();
                this.slopeRight = this.physics.add.staticGroup();
                this.bouncePads = this.physics.add.staticGroup();
                this.knockbackZones = this.physics.add.staticGroup();
                this.checkpoints = this.physics.add.staticGroup();
                this.fakeCheckpoints = this.physics.add.staticGroup();
                this.bombs = this.physics.add.group();
                this.spawnPoint = { x: 400, y: H - 50 };
                this.checkpointPositions = [
                    { x: 400, y: H - 520 }, { x: 400, y: H - 1220 }, { x: 400, y: H - 2020 },
                    { x: 400, y: H - 2820 }, { x: 400, y: H - 3580 }, { x: 400, y: H - 4440 },
                    { x: 400, y: H - 5300 }, { x: 400, y: H - 6200 }, { x: 400, y: H - 7100 },
                ];
                this.createWall(10, H / 2, 20, H);
                this.createWall(W - 10, H / 2, 20, H);
                this.createLevel();
                this.player = new Player(this, 400, H - 50);
                this.playerSprite = this.player.getSprite();
                this.cameras.main.setBounds(0, 0, W, H);
                this.cameras.main.startFollow(this.playerSprite, true, 0.1, 0.1);
                this.physics.add.collider(this.playerSprite, this.platforms);
                this.physics.add.collider(this.playerSprite, this.walls);
                this.physics.add.collider(this.playerSprite, this.iceBlocks, p => { if (p.body.touching.down) p.body.velocity.x *= 1.03; });
                this.physics.add.collider(this.playerSprite, this.slopeLeft, p => { if (p.body.touching.down) p.body.velocity.x -= 8; });
                this.physics.add.collider(this.playerSprite, this.slopeRight, p => { if (p.body.touching.down) p.body.velocity.x += 8; });
                this.physics.add.collider(this.playerSprite, this.bouncePads, (p, pad) => { if (p.body.touching.down) { p.setVelocityY(-450); pad.setFillStyle(0x00ff00); this.time.delayedCall(200, () => pad.setFillStyle(0xff00ff)); } });
                this.physics.add.overlap(this.playerSprite, this.knockbackZones, () => this.playerFall());
                this.physics.add.overlap(this.playerSprite, this.checkpoints, (p, cp) => { if (!cp.activated) { cp.activated = true; cp.setFillStyle(0x00ff00); this.spawnPoint = { x: cp.x, y: cp.y - 30 }; this.showMessage('‚úÖ Checkpoint!'); } });
                this.physics.add.collider(this.playerSprite, this.fakeCheckpoints, (p, fake) => { if (!fake.triggered) { fake.triggered = true; this.showMessage('üòà FAKE!'); this.time.delayedCall(300, () => { fake.body.enable = false; fake.setAlpha(0.3); }); } });
                this.physics.add.overlap(this.playerSprite, this.bombs, (p, bomb) => this.hitByBomb(bomb));
                this.physics.add.overlap(this.playerSprite, this.finishZone, () => this.levelComplete());
                this.wonkyControls = new WonkyControls(this);
                this.wonkyControls.setPlayer(this.playerSprite);
                this.wonkyControls.start();
                this.keys = { W: this.input.keyboard.addKey('W'), A: this.input.keyboard.addKey('A'), D: this.input.keyboard.addKey('D'), SPACE: this.input.keyboard.addKey('SPACE'), UP: this.input.keyboard.addKey('UP'), LEFT: this.input.keyboard.addKey('LEFT'), RIGHT: this.input.keyboard.addKey('RIGHT') };
                for (let i = 0; i <= 9; i++) this.input.keyboard.on('keydown-' + ['ZERO', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE'][i], () => this.teleportTo(i === 0 ? 9 : i - 1));
                this.airplaneTimer = this.time.addEvent({ delay: 8000, callback: () => this.spawnAirplane(), loop: true });
                this.cameras.main.fadeIn(500);
            }
            spawnAirplane() {
                const playerY = this.playerSprite.y;
                const direction = Math.random() > 0.5 ? 1 : -1;
                const startX = direction > 0 ? -50 : 850;
                const airplane = this.add.text(startX, playerY - 100, '‚úàÔ∏è', { fontSize: '40px' }).setOrigin(0.5);
                if (direction < 0) airplane.setFlipX(true);
                let dropped = false;
                this.tweens.add({
                    targets: airplane, x: direction > 0 ? 850 : -50, duration: 3000,
                    onUpdate: () => {
                        if (!dropped && Math.abs(airplane.x - this.playerSprite.x) < 150) {
                            dropped = true;
                            this.dropBombs(airplane.x, airplane.y + 20, direction);
                        }
                    },
                    onComplete: () => airplane.destroy()
                });
                this.showMessage('‚úàÔ∏è Bomber incoming!');
            }
            dropBombs(x, y, direction) {
                const count = Phaser.Math.Between(3, 5);
                for (let i = 0; i < count; i++) {
                    this.time.delayedCall(i * 80, () => {
                        const bomb = this.add.circle(x + Phaser.Math.Between(-40, 40), y, 10, 0xff0000);
                        bomb.setStrokeStyle(2, 0xffff00);
                        this.physics.add.existing(bomb);
                        bomb.body.setBounce(0.9, 0.9);
                        bomb.body.setCircle(10);
                        bomb.body.setVelocity(direction * Phaser.Math.Between(20, 60), Phaser.Math.Between(80, 150));
                        bomb.body.setGravityY(400);
                        bomb.body.setDrag(30, 0);
                        bomb.direction = direction;
                        this.bombs.add(bomb);
                        this.physics.add.collider(bomb, this.platforms);
                        this.physics.add.collider(bomb, this.iceBlocks);
                        this.physics.add.collider(bomb, this.walls);
                        this.time.delayedCall(8000, () => { if (bomb.active) bomb.destroy(); });
                    });
                }
            }
            hitByBomb(bomb) {
                if (!this.player.bombStunned) {
                    this.player.hitByBomb(bomb.direction || (Math.random() > 0.5 ? 1 : -1));
                    this.showMessage('üí• BOOM! Ch·∫°y lo·∫°n 0.5s!');
                    this.cameras.main.shake(200, 0.01);
                }
                bomb.destroy();
            }
            teleportTo(index) {
                const H = GameSettings.worldHeight;
                if (index === 9) { this.playerSprite.setPosition(400, H - 7100); this.showMessage('üèÜ FINISH!'); }
                else { const pos = this.checkpointPositions[index]; this.playerSprite.setPosition(pos.x, pos.y - 30); this.spawnPoint = { x: pos.x, y: pos.y - 30 }; this.showMessage('üöÄ CP' + (index + 1)); }
                this.playerSprite.setVelocity(0, 0);
            }
            playerFall() { this.player.knockDown(); GameState.addFall(); this.time.delayedCall(600, () => { this.playerSprite.setPosition(this.spawnPoint.x, this.spawnPoint.y); this.playerSprite.setVelocity(0, 0); }); }
            createBackground() {
                const H = GameSettings.worldHeight;
                for (let i = 0; i < H; i += 600) { const g = this.add.graphics(); g.fillStyle(Phaser.Display.Color.GetColor(26 + (i / H) * 100, 33 + (i / H) * 100, 62 + (i / H) * 140)); g.fillRect(0, H - i - 600, 800, 600); }
                for (let i = 0; i < 300; i++) this.add.circle(Phaser.Math.Between(0, 800), Phaser.Math.Between(0, H), Phaser.Math.Between(1, 2), 0xffffff, Phaser.Math.FloatBetween(0.2, 0.5));
            }
            createLevel() {
                const H = GameSettings.worldHeight;
                this.createPlatform(400, H - 25, 400, 30);
                // Zone 1 (0-50m)
                this.createPlatform(200, H - 70, 160, 20); this.createPlatform(500, H - 120, 160, 20);
                this.createPlatform(250, H - 170, 160, 20); this.createPlatform(500, H - 220, 160, 20);
                this.createPlatform(200, H - 270, 160, 20); this.createPlatform(500, H - 320, 160, 20);
                this.createPlatform(250, H - 370, 160, 20); this.createPlatform(500, H - 420, 160, 20);
                this.createPlatform(200, H - 470, 160, 20);
                this.createCheckpoint(400, H - 520); this.createPlatform(400, H - 520, 200, 25);
                // Zone 2 (50-120m)
                this.createPlatform(250, H - 580, 150, 20); this.createPlatform(550, H - 640, 150, 20);
                this.createFakeCheckpoint(250, H - 700);
                this.createPlatform(250, H - 700, 150, 20); this.createPlatform(550, H - 760, 150, 20);
                this.createPlatform(250, H - 820, 150, 20); this.createPlatform(550, H - 880, 150, 20);
                this.createPlatform(250, H - 940, 150, 20); this.createPlatform(550, H - 1000, 150, 20);
                this.createPlatform(250, H - 1060, 150, 20); this.createPlatform(550, H - 1120, 150, 20);
                this.createPlatform(300, H - 1180, 150, 20); this.createPlatform(400, H - 1150, 50, 20);
                this.createCheckpoint(400, H - 1220); this.createPlatform(400, H - 1220, 200, 25);
                // Zone 3 - Ice (120-200m)
                this.createIce(280, H - 1280, 140, 20); this.createIce(520, H - 1340, 140, 20);
                this.createPlatform(280, H - 1400, 140, 20); this.createIce(520, H - 1460, 140, 20);
                this.createIce(280, H - 1520, 140, 20); this.createPlatform(520, H - 1580, 140, 20);
                this.createFakeCheckpoint(520, H - 1640);
                this.createIce(280, H - 1640, 140, 20); this.createIce(520, H - 1700, 140, 20);
                this.createPlatform(280, H - 1760, 140, 20); this.createIce(520, H - 1820, 140, 20);
                this.createIce(280, H - 1880, 140, 20); this.createPlatform(520, H - 1940, 140, 20);
                this.createPlatform(350, H - 2000, 150, 20);
                this.createCheckpoint(400, H - 2020); this.createPlatform(400, H - 2020, 200, 25);
                // Zone 4 - Bounce (200-280m)
                this.createPlatform(300, H - 2080, 160, 20); this.createBouncePad(500, H - 2100, 80);
                this.createPlatform(400, H - 2170, 160, 20); this.createPlatform(550, H - 2240, 160, 20);
                this.createBouncePad(280, H - 2260, 80); this.createPlatform(450, H - 2340, 160, 20);
                this.createPlatform(300, H - 2410, 160, 20); this.createBouncePad(530, H - 2430, 80);
                this.createPlatform(400, H - 2510, 160, 20); this.createPlatform(550, H - 2580, 160, 20);
                this.createBouncePad(280, H - 2600, 80); this.createPlatform(420, H - 2680, 160, 20);
                this.createPlatform(300, H - 2750, 160, 20);
                this.createCheckpoint(400, H - 2820); this.createPlatform(400, H - 2820, 200, 25);
                // Zone 5 - Mix (280-360m)
                this.createIce(280, H - 2880, 140, 20); this.createPlatform(520, H - 2940, 140, 20);
                this.createFakeCheckpoint(280, H - 3000);
                this.createIce(280, H - 3000, 140, 20); this.createPlatform(520, H - 3060, 140, 20);
                this.createIce(280, H - 3120, 140, 20); this.createPlatform(520, H - 3180, 140, 20);
                this.createIce(280, H - 3240, 140, 20); this.createPlatform(520, H - 3300, 140, 20);
                this.createIce(280, H - 3360, 140, 20); this.createPlatform(520, H - 3420, 140, 20);
                this.createIce(280, H - 3480, 140, 20); this.createPlatform(350, H - 3540, 150, 20);
                this.createCheckpoint(400, H - 3580); this.createPlatform(400, H - 3580, 200, 25);
                // Zone 6 (360-440m)
                this.createPlatform(280, H - 3640, 150, 20); this.createPlatform(520, H - 3700, 150, 20);
                this.createPlatform(280, H - 3760, 150, 20); this.createPlatform(520, H - 3820, 150, 20);
                this.createPlatform(280, H - 3880, 150, 20); this.createPlatform(520, H - 3940, 150, 20);
                this.createPlatform(280, H - 4000, 150, 20); this.createPlatform(520, H - 4060, 150, 20);
                this.createPlatform(280, H - 4120, 150, 20); this.createPlatform(520, H - 4180, 150, 20);
                this.createPlatform(280, H - 4240, 150, 20); this.createPlatform(520, H - 4300, 150, 20);
                this.createPlatform(280, H - 4360, 150, 20); this.createPlatform(350, H - 4420, 150, 20);
                this.createCheckpoint(400, H - 4440); this.createPlatform(400, H - 4440, 200, 25);
                // Zone 7 - EASIER (440-530m) - More space between platforms!  
                this.createPlatform(300, H - 4500, 160, 20); this.createPlatform(400, H - 4550, 160, 20); this.createPlatform(500, H - 4600, 160, 20);
                this.createPlatform(400, H - 4650, 160, 20); this.createPlatform(300, H - 4700, 160, 20); this.createPlatform(400, H - 4750, 160, 20);
                this.createPlatform(500, H - 4800, 160, 20); this.createPlatform(400, H - 4850, 160, 20); this.createPlatform(300, H - 4900, 160, 20);
                this.createPlatform(400, H - 4950, 160, 20); this.createPlatform(500, H - 5000, 160, 20); this.createPlatform(400, H - 5050, 160, 20);
                this.createPlatform(300, H - 5100, 160, 20); this.createPlatform(400, H - 5150, 160, 20); this.createPlatform(500, H - 5225, 120, 20);
                this.createPlatform(300, H - 5250, 160, 20);
                this.createCheckpoint(400, H - 5300); this.createPlatform(400, H - 5300, 200, 25);
                // Zone 8 - GAPS EASIER (530-620m)
                this.createPlatform(300, H - 5380, 150, 20); this.createPlatform(500, H - 5450, 150, 20);
                this.createPlatform(300, H - 5530, 150, 20); this.createPlatform(500, H - 5600, 150, 20);
                this.createPlatform(300, H - 5680, 150, 20); this.createPlatform(500, H - 5750, 150, 20);
                this.createPlatform(300, H - 5830, 150, 20); this.createPlatform(500, H - 5900, 150, 20);
                this.createPlatform(400, H - 5990, 180, 20); this.createPlatform(400, H - 6080, 180, 20);
                this.createPlatform(200, H - 6140, 60, 20); this.createPlatform(650, H - 6035, 100, 20);
                this.createCheckpoint(400, H - 6200); this.createPlatform(400, H - 6200, 200, 25);
                // Zone 9 - MIXED EASIER (620-710m)
                this.createPlatform(280, H - 6280, 160, 20); this.createPlatform(520, H - 6350, 160, 20);
                this.createPlatform(280, H - 6430, 160, 20); this.createIce(520, H - 6500, 160, 20);
                this.createPlatform(280, H - 6580, 160, 20); this.createPlatform(520, H - 6650, 160, 20);
                this.createIce(280, H - 6730, 160, 20); this.createPlatform(520, H - 6800, 160, 20);
                this.createPlatform(400, H - 6900, 180, 20); this.createPlatform(400, H - 7000, 180, 20);
                this.createPlatform(200, H - 7040, 20, 20); this.createPlatform(650, H - 6935, 100, 20);
                this.createFinishZone(400, H - 7100, 200, 60); this.createPlatform(400, H - 7100, 200, 25);
                // Zone 10 - REMOVED (Game ends at 710m)






            }
            createWall(x, y, w, h) { const wall = this.add.rectangle(x, y, w, h, 0x2d2d2d); this.physics.add.existing(wall, true); this.walls.add(wall); }
            createPlatform(x, y, w, h) { const p = this.add.rectangle(x, y, w, h, 0x8B4513); p.setStrokeStyle(2, 0x5d3a1a); this.physics.add.existing(p, true); this.platforms.add(p); this.add.rectangle(x, y - h / 2 - 3, w, 6, 0x228B22); }
            createIce(x, y, w, h) { const ice = this.add.rectangle(x, y, w, h, 0x87CEEB); ice.setStrokeStyle(2, 0x4682B4).setAlpha(0.85); this.physics.add.existing(ice, true); this.iceBlocks.add(ice); }
            createBouncePad(x, y, w) { const pad = this.add.rectangle(x, y, w, 12, 0xff00ff); pad.setStrokeStyle(2, 0xcc00cc); this.physics.add.existing(pad, true); this.bouncePads.add(pad); this.tweens.add({ targets: pad, scaleY: 0.7, duration: 300, yoyo: true, repeat: -1 }); }
            createCheckpoint(x, y) { const cp = this.add.rectangle(x, y, 30, 50, 0xffff00, 0.6); cp.setStrokeStyle(3, 0xffa500); cp.activated = false; this.physics.add.existing(cp, true); this.checkpoints.add(cp); this.add.text(x, y - 35, 'üö©', { fontSize: '20px' }).setOrigin(0.5); }
            createFakeCheckpoint(x, y) { const fake = this.add.rectangle(x, y, 30, 50, 0x1E90FF, 0.6); fake.setStrokeStyle(3, 0x0066cc); fake.triggered = false; this.physics.add.existing(fake, true); this.fakeCheckpoints.add(fake); this.add.text(x, y - 35, 'üö©', { fontSize: '20px' }).setOrigin(0.5); }
            createFinishZone(x, y, w, h) { this.finishZone = this.add.rectangle(x, y, w, h, 0x00ff00, 0.3); this.finishZone.setStrokeStyle(4, 0x00ff00); this.physics.add.existing(this.finishZone, true); this.add.text(x, y, 'üèÜ', { fontSize: '40px' }).setOrigin(0.5); this.tweens.add({ targets: this.finishZone, alpha: 0.1, duration: 500, yoyo: true, repeat: -1 }); }
            showMessage(t) { const m = document.getElementById('troll-message'); m.textContent = t; m.classList.remove('hidden'); setTimeout(() => m.classList.add('hidden'), 2000); }
            levelComplete() {
                if (!this.player.canControl) return;
                this.wonkyControls.stop();
                this.player.canControl = false;
                this.playerSprite.body.moves = false; // Stop physics to prevent falling
                this.airplaneTimer.remove();
                this.showMessage('üèÜ 710m CONQUERED! üèÜ');
                this.time.delayedCall(2000, () => {
                    this.showMessage('Falls: ' + GameState.falls);
                    this.time.delayedCall(3000, () => this.scene.start('MenuScene')); // Return to menu
                });
            }
            update(time, delta) {
                const k = { left: this.keys.A.isDown || this.keys.LEFT.isDown, right: this.keys.D.isDown || this.keys.RIGHT.isDown, jump: Phaser.Input.Keyboard.JustDown(this.keys.W) || Phaser.Input.Keyboard.JustDown(this.keys.SPACE) || Phaser.Input.Keyboard.JustDown(this.keys.UP), jumpHeld: this.keys.W.isDown || this.keys.SPACE.isDown || this.keys.UP.isDown };
                this.player.update(k, this.wonkyControls);
            }
        }

        const GameState = { falls: 0, addFall() { this.falls++; document.getElementById('death-count').textContent = this.falls; }, reset() { this.falls = 0; document.getElementById('death-count').textContent = 0; } };
        const game = new Phaser.Game({ type: Phaser.AUTO, width: 800, height: 600, parent: 'game-container', backgroundColor: '#1a1a2e', pixelArt: true, physics: { default: 'arcade', arcade: { gravity: { y: 800 }, debug: false } }, scene: [MenuScene, GameScene] });

        function showCatPopup() {
            const popup = document.getElementById('cat-popup');
            popup.classList.remove('hidden');
            if (game.scene.scenes[1] && game.scene.scenes[1].player) {
                game.scene.scenes[1].player.catStun();
                game.scene.scenes[1].showMessage('üòø M√®o c∆∞·ªùi b·∫°n! Ch·∫°y lo·∫°n 0.5s!');
            }
            setTimeout(() => popup.classList.add('hidden'), 3000);
        }
    </script>
    <style>
        #teleport-hint {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 14px;
            z-index: 1000;
        }

        #cat-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #ff0000;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            z-index: 9999;
            animation: catShake 0.3s infinite;
        }

        #cat-popup img {
            width: 300px;
            height: 300px;
            object-fit: cover;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }

        #cat-popup p {
            color: #ff6b6b;
            font-size: 24px;
            font-weight: bold;
            margin-top: 20px;
            font-family: 'Comic Sans MS', cursive;
            text-shadow: 2px 2px 4px #000;
        }

        #cat-popup.hidden {
            display: none;
        }

        @keyframes catShake {

            0%,
            100% {
                transform: translate(-50%, -50%) rotate(-2deg);
            }

            50% {
                transform: translate(-50%, -50%) rotate(2deg);
            }
        }
    </style>
</body>

</html>